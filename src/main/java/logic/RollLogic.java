package logic;

import dicerolling.DicePoolBuilder;
import dicerolling.RollResult;
import doom.DoomHandler;
import org.apache.commons.lang3.tuple.Triple;
import org.javacord.api.entity.message.Message;
import org.javacord.api.entity.message.MessageBuilder;
import org.javacord.api.entity.message.MessageFlag;
import org.javacord.api.entity.message.embed.EmbedBuilder;
import org.javacord.api.entity.user.User;
import org.javacord.api.event.message.MessageCreateEvent;
import org.javacord.api.interaction.SlashCommandInteraction;
import org.javacord.api.interaction.SlashCommandInteractionOption;
import org.javacord.api.interaction.SlashCommandOption;
import org.javacord.api.interaction.SlashCommandOptionType;
import org.javacord.api.interaction.callback.InteractionImmediateResponseBuilder;
import org.javacord.api.interaction.callback.InteractionOriginalResponseUpdater;
import pw.mihou.velen.interfaces.*;
import sheets.PlotPointHandler;
import util.RandomColor;
import util.UtilFunctions;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

/**
 * Rolls a pool of dice based on the input. After rolling, adds doom points to doom pool and makes appropriate changes the player's plot point count based on input options. If the DM is rolling, plot points they spend come from the doom point pool.
 */
public class RollLogic implements VelenSlashEvent, VelenEvent {
    public static void setupRollCommand(Velen velen) {
        RollLogic rollLogic = new RollLogic();
        final List<SlashCommandOption> rollCommandOptions = getRollCommandOptions();
        rollCommandOptions.add(SlashCommandOption.create(SlashCommandOptionType.BOOLEAN, "opportunity", "Allows for opportunities on the roll. Defaults to true.", false));
        VelenCommand.ofHybrid("roll", "Rolls some dice!", velen, rollLogic, rollLogic).addOptions(rollCommandOptions.toArray(new SlashCommandOption[0])).addShortcuts("r").setServerOnly(true, 468046159781429250L).attach();

    }
//    /**
//     * Rolls a dice pool and sends the output to the channel the message was sent in
//     * <p>
//     * Performs side effects based on the dice pool, sender, and if the getResults is a reroll
//     *
//     * @param channel  The channel the command was sent from
//     * @param message  The message for the command
//     * @param dicePool The dice pool to be rolled
//     * @param isReroll Whether the getResults is a reroll
//     */
//    private static void rollPoolAndSend(TextChannel channel, Message message, DicePool dicePool, boolean isReroll) {
//        DiceRoller diceRoller = new DiceRoller(dicePool);
//        final CompletableFuture<Message> sentMessageFuture = channel.sendMessage(diceRoller.generateResults(message.getAuthor())).exceptionally(ExceptionLogger.get());
//        sentMessageFuture.thenAcceptAsync(sentMessage -> {
//            if (!isReroll) {
//                handlePlotPointChanges(message, dicePool.getPlotPointsSpent(), dicePool.getPlotPointDiscount());
//            }
//            if (!Storytellers.isMessageAuthorStoryteller(message.getAuthor()) && dicePool.areOpportunitiesEnabled()) {
//                handleOpportunities(message.getAuthor(), sentMessage, channel, dicePool.areOpportunitiesEnabled(), diceRoller.getDoom());
//            }
//            if (dicePool.isEnhancementEnabled()) {
//                PlotPointEnhancementHelper.addPlotPointEnhancementEmojis(sentMessage);
//                queueReactionRemoval(sentMessage);
//            }
//            if (!isReroll) {
//                attachRerollReaction(message, dicePool, diceRoller, sentMessage, channel);
//            }
//        });
//    }
//
//    /**
//     * Re-rolls the previous getResults. Plot points spent by the player are not spent again, plot and doom points from opportunites are reverted before the re-getResults.
//     *
//     * @param channel  The channel the reroll is in
//     * @param message  The message that started the reroll
//     * @param dicePool The dice pool to be re-rolled
//     * @param doom     The number of doom points generated by the previous getResults
//     */
//    private static void reroll(TextChannel channel, Message message, DicePool dicePool, int doom) {
//        // Revert opportunities and plot point spending
//        if (dicePool.areOpportunitiesEnabled()) {
//            final EmbedBuilder doomEmbed = DoomHandler.addDoom(doom * -1);
//            final boolean isThereAnOpportunity = doom > 0;
//            final int changeInPlotPoints = (isThereAnOpportunity ? -1 : 0) + dicePool.getPlotPointsSpent() - dicePool.getPlotPointDiscount();
//            if (changeInPlotPoints != 0) {
//                final ArrayList<Triple<User, Integer, Integer>> plotPointChanges = new ArrayList<>();
//                PlotPointHandler.addPlotPointsToUser(message.getUserAuthor().get(), changeInPlotPoints, plotPointChanges, new ArrayList<>()).thenAccept(integer -> channel.sendMessage(PlotPointHandler.generateEmbed(plotPointChanges, channel, message.getAuthor()))).join();
//            }
//            if (doom * -1 != 0) {
//                channel.sendMessage(doomEmbed).join();
//            }
//        }
//        rollPoolAndSend(channel, message, dicePool, true);
//    }
//
//    /**
//     * Attach the reroll reaction and attach a listener that lasts for 60 seconds (same as the other reacts)
//     *
//     * @param userMessage The message containing the getResults command
//     * @param dicePool    The dice pool for rolling
//     * @param diceRoller  The dice roller object containing the result of the getResults
//     * @param sentMessage The message that contains the embed with the getResults result
//     * @param channel     The channel the message was sent from
//     */
//    public static void attachRerollReaction(Message userMessage, DicePool dicePool, DiceRoller diceRoller, Message sentMessage, TextChannel channel) {
//        sentMessage.addReaction(EmojiParser.parseToUnicode(":repeat:")).thenAccept(unused -> sentMessage.addReactionAddListener(event -> onRerollReact(userMessage, dicePool, diceRoller, sentMessage, channel, event)).removeAfter(60, TimeUnit.SECONDS));
//    }
//
//    public static void rollPoolAndSend(TextChannel channel, Message message, DicePool dicePool) {
//        rollPoolAndSend(channel, message, dicePool, false);
//    }
//
//    /**
//     * Deletes the reactions from a message after 60 seconds
//     *
//     * @param sentMessage The message containing the embed for the getResults
//     */
//    private static void queueReactionRemoval(Message sentMessage) {
//        sentMessage.getApi().getThreadPool().getScheduler().schedule(() -> PlotPointEnhancementHelper.removeEnhancementEmojis(sentMessage), 60, TimeUnit.SECONDS);
//    }
//
//    /**
//     * Adds plot points and doom points when rolling a 1
//     *
//     * @param author                  The author that made the getResults
//     * @param rollEmbedMessage        The message with the embed for the getResults
//     * @param channel                 The channel the getResults was made in
//     * @param areOpportunitiesEnabled Whether opportunities are enabled
//     * @param doomGenerated           The amount of doom generated
//     */
//    private static void handleOpportunities(MessageAuthor author, Message rollEmbedMessage, TextChannel channel, boolean areOpportunitiesEnabled, int doomGenerated) {
//        // Send embed for plot points and doom if there's an opportunity
//        if (areOpportunitiesEnabled && doomGenerated >= 1) {
//            rollEmbedMessage.addReaction(EmojiParser.parseToUnicode(":eight_pointed_black_star:"));
//            EmbedBuilder doomEmbed = DoomHandler.addDoom(doomGenerated);
//            ArrayList<Triple<User, Integer, Integer>> plotPointChanges = new ArrayList<>();
//            if (author.asUser().isPresent()) {
//                PlotPointHandler.addPlotPointsToUser(author.asUser().get(), 1, plotPointChanges, new ArrayList<>())
//                        .thenAccept(integer -> channel.sendMessage(PlotPointHandler.generateEmbed(plotPointChanges, channel, author).setTitle("An opportunity!")))
//                        .join();
//                doomEmbed.setFooter(MessageFormat.format("Generated by {0}!", UtilFunctions.getUsernameInChannel(author.asUser().get(), channel)));
//            }
//            channel.sendMessage(doomEmbed);
//        }
//    }
//
//    /**
//     * Sends an embed for spending plot points on a getResults
//     *
//     * @param message     The message of the command
//     * @param pointsSpent The number of plot points spent
//     * @param discount    The discount on the getResults
//     */
//    private static void handlePlotPointChanges(Message message, int pointsSpent, int discount) {
//        final int plotPointsSpent = pointsSpent - discount;
//        MessageAuthor author = message.getAuthor();
//        TextChannel channel = message.getChannel();
//        if (plotPointsSpent != 0) {
//            if (Storytellers.isMessageAuthorStoryteller(author)) {
//                //DMs use doom points as plot points and 1s do not increase the doom pool
//                EmbedBuilder doomEmbed = DoomHandler.addDoom(plotPointsSpent * -1);
//                channel.sendMessage(doomEmbed.setTitle(MessageFormat.format("Using {0} doom points!", plotPointsSpent)));
//            }
//            else if (author.asUser().isPresent()) {
//                //Players have to spend plot points and gain doom points on opportunities
//                ArrayList<Triple<User, Integer, Integer>> plotPointChanges = new ArrayList<>();
//                PlotPointHandler.addPlotPointsToUser(author.asUser().get(), plotPointsSpent * -1, plotPointChanges, new ArrayList<>())
//                        .thenAccept(integer -> channel.sendMessage(PlotPointHandler.generateEmbed(plotPointChanges, channel, author)
//                                .setTitle(MessageFormat.format("Using {0} plot points!", plotPointsSpent)))).join();
//            }
//        }
//    }
//
//    /**
//     * When a user reacts to the repeat reaction,
//     *
//     * @param userMessage The message the user sent to getResults dice
//     * @param dicePool    The dice pool for the getResults
//     * @param diceRoller  The dice roller object containing the results of the getResults
//     * @param sentMessage The message with an embed containing result of the getResults
//     * @param channel     The channel the message was sent in
//     * @param event       The reaction event
//     */
//    private static void onRerollReact(Message userMessage, DicePool dicePool, DiceRoller diceRoller, Message sentMessage, TextChannel channel, ReactionAddEvent event) {
//        if (event.getUser().map(user -> !user.isYourself()).orElse(false) && event.getReaction().map(reaction -> reaction.getEmoji().equalsEmoji(EmojiParser.parseToUnicode(":repeat:"))).orElse(false)) {
//            event.addReactionsToMessage(EmojiParser.parseToUnicode(":bulb:"));
//            PlotPointEnhancementHelper.removeEnhancementEmojis(sentMessage).thenAccept(reactionsRemoved -> reroll(channel, userMessage, dicePool, diceRoller.getDoom()));
//        }
//    }


    /**
     * Creates a completable future of the embeds that have to be sent
     *
     * @param username        The name of the user in the channel the embeds will be sent in
     * @param user            The user, used for getting the user's icon
     * @param rollResult      The embed that contains the result of the roll. This function adds a footer and a random color to the embed.
     * @param doomGenerated   The amount of doom generated by the roll to generate embeds for opportunities and doom increases
     * @param plotPointsSpent The amount of plot points spent on the roll, used to generate embeds for plot point usage
     * @return A completable future with the embeds generated by the roll
     */
    public static CompletableFuture<EmbedBuilder[]> getRollEmbeds(String username, User user, EmbedBuilder rollResult, int doomGenerated, int plotPointsSpent) {
        CompletableFuture<List<EmbedBuilder>> rollResultEmbeds = CompletableFuture.completedFuture(new ArrayList<>());
        rollResultEmbeds = UtilFunctions.appendElementToCompletableFutureList(rollResultEmbeds, rollResult.setFooter("Requested by " + username, user.getAvatar()).setColor(RandomColor.getRandomColor()));

        // Add plot point expenditure embeds
        if (plotPointsSpent != 0) {
            final Optional<Integer> plotPointModifyFuture = PlotPointHandler.addPlotPointsToUser(user, plotPointsSpent * -1).join();
            final Optional<EmbedBuilder> plotPointSpentEmbed = plotPointModifyFuture.map(integer -> new EmbedBuilder()
                    .setTitle("Using " + plotPointsSpent + " plot points!")
                    .setColor(RandomColor.getRandomColor())
                    .addField(username, (integer + plotPointsSpent) + " → " + integer));
            if (plotPointSpentEmbed.isPresent()) {
                rollResultEmbeds = UtilFunctions.appendElementToCompletableFutureList(rollResultEmbeds, plotPointSpentEmbed.get());
            }
        }
        // Add doom embeds
        if (doomGenerated > 0) {
            DoomHandler.addDoom(doomGenerated);
            final CompletableFuture<Optional<EmbedBuilder>> opportunityFuture = PlotPointHandler.addPlotPointsToUser(user, 1)
                    .thenApply(newPlotPoints -> newPlotPoints.map(integer -> new EmbedBuilder()
                            .setTitle("An opportunity!")
                            .setColor(Color.DARK_GRAY)
                            .addField(username, (integer - 1) + " → " + integer)
                            .addField(DoomHandler.getActivePool(), (DoomHandler.getDoom() - doomGenerated) + " → " + DoomHandler.getDoom())));
            rollResultEmbeds = UtilFunctions.appendOptionalToCompletableFutureList(rollResultEmbeds, opportunityFuture);
        }

        return rollResultEmbeds.thenApply(embedBuilders -> embedBuilders.toArray(new EmbedBuilder[0]));
    }

    @SuppressWarnings("OptionalUsedAsFieldOrParameterType")
    static void handleSlashCommandRoll(SlashCommandInteraction event, InteractionImmediateResponseBuilder firstResponder, Optional<String> dicePool, Integer discount, Integer diceKept, Optional<Boolean> enhanceable, Boolean opportunity) {
        final User user = event.getUser();
        final Optional<Triple<EmbedBuilder, Integer, Integer>> embedBuilder = dicePool.map(s -> new DicePoolBuilder(user, s).withDiceKept(diceKept).withDiscount(discount).withEnhanceable(enhanceable).withOpportunity(opportunity))
                .flatMap(DicePoolBuilder::getResults)
                .map(rollResult -> Triple.of(rollResult.getResultEmbed(), rollResult.getDoomGenerated(), rollResult.getPlotPointsSpent()));
        if (embedBuilder.isPresent()) {
            final CompletableFuture<InteractionOriginalResponseUpdater> respondLater = event.respondLater();
            final CompletableFuture<EmbedBuilder[]> rollEmbeds = getRollEmbeds(event.getChannel().map(channel -> UtilFunctions.getUsernameInChannel(user, channel)).orElseGet(user::getName), user, embedBuilder.get().getLeft(), embedBuilder.get().getMiddle(), embedBuilder.get().getRight());
            respondLater.thenAcceptBoth(rollEmbeds, (updater, embedBuilders) -> updater.addEmbeds(embedBuilders).update());
        }
        else {
            firstResponder.setContent("Invalid dice pool!").setFlags(MessageFlag.EPHEMERAL).respond();
        }
    }

    static void handleTextCommandRoll(MessageCreateEvent event, User user, DicePoolBuilder builder) {
        if (builder.getResults().isPresent()) {
            RollResult rollResult = builder.getResults().get();
            final CompletableFuture<EmbedBuilder[]> rollEmbeds = getRollEmbeds(UtilFunctions.getUsernameInChannel(user, event.getChannel()), user, rollResult.getResultEmbed(), rollResult.getDoomGenerated(), rollResult.getPlotPointsSpent());
            rollEmbeds.thenAccept(embeds -> new MessageBuilder().addEmbeds(embeds).send(event.getChannel()));
        }
        else {
            event.getChannel().sendMessage("Invalid dice pool!");
        }
    }

    static List<SlashCommandOption> getRollCommandOptions() {
        List<SlashCommandOption> options = new ArrayList<>();
        options.add(SlashCommandOption.create(SlashCommandOptionType.STRING, "dicepool", "The dice pool to roll with.", true));
        options.add(SlashCommandOption.create(SlashCommandOptionType.INTEGER, "discount", "The number of plot points to discount (negative results in a plot point cost increase).", false));
        options.add(SlashCommandOption.create(SlashCommandOptionType.INTEGER, "dicekept", "The number of dice kept. Keeps two dice by default.", false));
        options.add(SlashCommandOption.create(SlashCommandOptionType.BOOLEAN, "enhanceable", "Allows the roll to be enhanced after the roll.", false));
        return options;
    }


    @Override
    public void onEvent(MessageCreateEvent event, Message message, User user, String[] args) {
        String dicePool = String.join(" ", args);

        //Variables containing getResults information
        DicePoolBuilder builder = new DicePoolBuilder(user, dicePool).withOpportunity(true);
        handleTextCommandRoll(event, user, builder);
    }

    @Override
    public void onEvent(SlashCommandInteraction event, User user, VelenArguments args, List<SlashCommandInteractionOption> options, InteractionImmediateResponseBuilder firstResponder) {
        final Boolean opportunity = event.getOptionBooleanValueByName("opportunity").orElse(true);
        final Integer discount = event.getOptionIntValueByName("discount").orElse(0);
        final Optional<String> dicePool = event.getOptionStringValueByName("dicepool");
        final Integer diceKept = event.getOptionIntValueByName("dicekept").orElse(2);
        final Optional<Boolean> enhanceable = event.getOptionBooleanValueByName("enhanceable");

        handleSlashCommandRoll(event, firstResponder, dicePool, discount, diceKept, enhanceable, opportunity);
    }

}
