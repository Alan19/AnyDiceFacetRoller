package dicerolling;

import discord.TwoDee;
import doom.DoomWriter;
import logic.RandomColor;
import org.javacord.api.entity.message.MessageAuthor;
import org.javacord.api.entity.message.embed.EmbedBuilder;
import sheets.PPManager;
import statistics.PoolOptions;
import statistics.RollResult;
import statistics.resultvisitors.DifficultyVisitor;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;

public class DiceRoller {

    public static final String NONE = "*none*";
    private final PoolOptions poolOptions;
    private final Random random = new Random();
    //The amount of doom generated by this dice roll
    private final RollResult rollResult;

    public DiceRoller(String content) {
        //Split up content
        ArrayList<String> args = new ArrayList<>(Arrays.asList(content.split(" ")));
        args.remove("~r");
        //Split dice into regular dice and plot dice
        poolOptions = new PoolOptions();
        DiceParameterHandler diceParameterHandler = new DiceParameterHandler(args, poolOptions);
        diceParameterHandler.addDiceToPools();
        rollResult = new RollResult(poolOptions.getTop());
    }

    public int getDoom() {
        return rollResult.getDoom();
    }

    public EmbedBuilder generateResults(MessageAuthor author) {
        //Roll the dice
        rollDice(random);
        //Build embed
        return buildResultEmbed(author, rollResult);
    }

    private EmbedBuilder buildResultEmbed(MessageAuthor author, RollResult result) {
        return new EmbedBuilder()
                .setTitle(TwoDee.getRollTitleMessage())
                .setAuthor(author)
                .setColor(RandomColor.getRandomColor())
                .addField("Regular dice", formatResults(result.getDice()), true)
                .addField("Picked", resultsToString(result.getKept()), true)
                .addField("Dropped", resultsToString(result.getDropped()), true)
                .addField("Plot dice", resultsToString(result.getPlotDice()), true)
                .addField("Kept dice", resultsToString(result.getKeptDice()), true)
                .addField("Flat bonuses", result.getFlatBonus() == 0 ? NONE : Integer.toString(result.getFlatBonus()), true)
                .addField("Total", String.valueOf(result.getResult()), true)
                .addField("Tier Hit", tiersHit(result.getResult()));
    }

    private String tiersHit(int total) {
        DifficultyVisitor difficultyVisitor = new DifficultyVisitor();
        if (total < 3) {
            return "None";
        }
        StringBuilder output = new StringBuilder();
        for (Map.Entry<Integer, String> diffEntry : difficultyVisitor.getDifficultyMap().entrySet()) {
            if (difficultyVisitor.generateStageDifficulty(diffEntry.getKey() + 1) > total) {
                output.append(diffEntry.getValue());
                break;
            }
        }
        if (total < 10) {
            return String.valueOf(output);
        }
        for (Map.Entry<Integer, String> diffEntry : difficultyVisitor.getDifficultyMap().entrySet()) {
            if (difficultyVisitor.generateStageExtraordinaryDifficulty(diffEntry.getKey() + 1) > total) {
                output.append(", Extraordinary ").append(diffEntry.getValue());
                break;
            }
        }
        return String.valueOf(output);
    }

    //Bold 1s to show total doom generated. Runs doom increasing method afterwards.
    private String formatResults(ArrayList<Integer> s) {
        StringBuilder resultString = new StringBuilder();
        if (s.size() > 1) {
            for (int i = 0; i < s.size() - 1; i++) {
                if (s.get(i) == 1) {
                    resultString.append("**1**, ");
                }
                else {
                    resultString.append(s.get(i)).append(", ");
                }
            }
            if (s.get(s.size() - 1) == 1) {
                resultString.append("**1**");
            }
            else {
                resultString.append(s.get(s.size() - 1));
            }
        }
        else if (s.size() == 1) {
            if (s.get(0) == 1) {
                resultString.append("**1**");
            }
            else {
                resultString.append(s.get(0));
            }
        }
        else {
            return NONE;
        }
        return resultString.toString();
    }

    // Username is stored as <@!140973544891744256>
    public EmbedBuilder addPlotPoints(MessageAuthor author) {
        if (rollResult.getDoom() != 0) {
            PPManager manager = new PPManager();
            String userID = author.getIdAsString();
            int oldPP = manager.getPlotPoints(userID);
            int newPP = manager.setPlotPoints(userID, oldPP + 1);
            return new EmbedBuilder()
                    .setAuthor(author)
                    .setDescription(oldPP + " â†’ " + newPP);
        }
        else {
            return null;
        }
    }

    public EmbedBuilder addDoom(int doomVal) {
        DoomWriter doomWriter = new DoomWriter();
        return doomWriter.addDoom(doomVal);
    }

    //Roll all of the dice. Plot dice have a minimum value of its maximum roll/2
    private void rollDice(Random random) {
        //Roll dice
        rollDie(random);
        rollKeptDie(random);
        rollPlotDice(random);
        addFlatBonus();
    }

    private void addFlatBonus() {
        for (int flatBonus : poolOptions.getFlatBonus()) {
            rollResult.addFlatBonuses(flatBonus);
        }
    }

    private void rollPlotDice(Random random) {
        //A plot die's minimum value is its number of faces / 2
        for (Integer pDice : poolOptions.getPlotDice()) {
            int pValue = random.nextInt(pDice) + 1;
            if (pValue < pDice / 2) {
                pValue = pDice / 2;
            }
            rollResult.addPlotDice(pValue);
        }
    }

    private void rollDie(Random random) {
        for (Integer die : poolOptions.getRegularDice()) {
            int diceVal = random.nextInt(die) + 1;
            rollResult.addDiceToResult(diceVal);
        }
    }

    private void rollKeptDie(Random random) {
        for (Integer keptDie : poolOptions.getKeptDice()) {
            int keptVal = random.nextInt(keptDie) + 1;
            rollResult.addKeptDice(keptVal);
        }
    }

    //Replaces brackets in the string. If the string is blank, returns "none" in italics
    private String resultsToString(ArrayList<Integer> result) {
        return result.isEmpty() ? NONE : result.stream().map(Object::toString).collect(Collectors.joining(", "));
    }

}
